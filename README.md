# TestTask
В тестовом задании сказано, что для решения задач не должны использоваться дополнительные библиотеки. Потому одно решение - максимально чистый проект использующий только <stdio.h> - решение в "simple.cpp". Однако по ходу выполнения задач, решил добавить альтернативные варианты с использованием расширений std - решение в файле "extended.cpp". В первом файле выдерживал более сишный формат, названия переменных и функций покороче, во втором более человечные и ёмкие.


> 1) Почему -1>>1 != 1>>1?

При логическом сдвиге влево младшие байты всегда заполняются нулями. При логическом сдвиге вправо учитывается "знаковость" переменной.
Если переменная типа signed и в старшем байте хранится 1 (что означает ее отрицательность), при логическом сдвиге вправо все "новые" старшие байты будут заполнены 1. Если же старший байт был 0 (то есть положительное число), сдвинутые байты заполнились бы нулями.
Данное правило удобно для грубого деления или умножения отрицательных чисел на значения степени 2 (важно не выходить за пределы типа данных). Также логический сдвиг вправо для unsigned переменных будет игнорировать значение старшего байта и всегда заполняет "новые" байты нулями.
Наглядно разберем задачу, а для упрощения будем считать на char'е.
-1 = 1111 1111, сдвигая на единицу вправо получим Х111 1111, так как старший байт сохранит свое значение, то и результат останется 1111 1111, что по прежнему равно -1. Иначе можно сказать, что при грубом делении -1 на 2 мы получим -1 (как бы -0.5 с округлением "вниз").
 1 = 0000 0001, сдвигая на единицу вправо получим Х000 0000, так как старший байт сохранит свое значение, то результат станет 0000 0000, что будет равняться 0. Аналогично, если 1 грубо поделим на 2, то получим 0 (как бы 0.5 с округлением "вниз").
Если бы значение было unsigned char 255 = 1111 1111, то при выполнении >> 1 стало бы 0111 1111, то есть 127, что и так же грубое деление на 2 с округлением вниз (floor 127.5).

Немного не в тему, но данная задача напомнила мне, что когда я был студентом, то предлагал одногруппникам рассчитать чему будет равна переменная "int x = 1^!~-1;". Теперь подумал, что в выражении не хватает битовых сдвигов)


> 2) Написать функцию для проверки, является ли палиндромом входная строка.

Решая данную задачу, не мог не заметить, что в классическом палиндромоме считаются только буквы и цифры, а остальные символы считаются как white-space. Не зная критериев оценки и исходя из примеров к заданию, я решил написать как строгую проверку, учитывающую совпадения всех символов, так и классическую.
При строгой проверке для "aa b  aa" функция выдаст false, при классической для "A man, a plan, a canal: Panama" выдаст true. Все зависит от конечной задачи, потому приложил оба решения isPalindrome и isClassicPalindrome соответственно.


> 3) Сгенерировать первые 30 чисел Фибоначчи. Удалить те из них, которые содержат цифру 1 на любой позиции (1, 12, 21, 144).

В данной задаче напротив решил уйти от классического решения. Числа Фибоначчи обычно приводят как пример использования рекурсивных функций. К сожалению, рекурсия, особенно глубокая, довольно ресурсоёмкая операция и способна забить весь стек.
Я также привел классическое решение через рекурсию, но в комментариях (функции classicFibWithFilter и fib). Для вычисление 46ого элемента на моем компьютере потребовалось около 5 минут. Если же для задачи реально необходимо использовать числа Фибоначчи (например, для генерации ракушкавидного уровня), то я так же в комментариях оставил оптимизированную функцию progressiveFib без использования рекурсии.
Конечную задачу, которая исключает все числа, содержащие 1 на любой позиции, реализовал в функции progressiveFibWhitFilter (и filteredFibonacci с использованием стандартного вектора в extended.cpp).


> 4) Написать функцию, которая будет разворачивать число задом наперед. На вход гарантированы неотрицательные целые числа.

Для данной задачи я нашел только одно оптимальное решение, через остатки деления на 10. Была идея преобразовывать число в строку, посимвольно разворачивать, например, чтобы добавить поддержку нецелых чисел. Но, я не придумал, для чего это может понадобиться.
В функции intReverse не стал обрабатывать "предельные" значения, так как не совсем ясно конечное применение, а так же чтобы не подключать <limits> или <iostream>. В комментариях оставил код для проверки этих случаев.
Во втором варианте в extended.cpp использовал немного иной алгоритм и он уже обрабатывает "предельные значения".
Так же интересными случаями были такие числа как 100, ведь формально их надо представлять как 001. В данной задаче не указано, нужно ли это делать, в реальной ситуации я бы оставил вопрос под задачей в тасктрекере.


---
Для данных задач не стал создавать юнит тесты, чтоб не плодить проекты. Производительность и правильность выполнения алгоритмов проверял на схожих задачах на сайте https://leetcode.com/problemset/all/ . Все решения были приняты системой достаточно оптимальными (90-100%).
Сложность второй (первая теоретическая) задачи линейная, прямо пропорциональна числу символов. Сложность третьей прямо пропорциональна исходному числу, а также определение единицы в составе числа прямо пропорциональна длине десятичного числа (аналогично для задания №4).

P.S.: По умолчанию в проекте запускается main из файла "simple.cpp", чтобы запустить main из "extended.cpp", надо переназвать главные функции.
